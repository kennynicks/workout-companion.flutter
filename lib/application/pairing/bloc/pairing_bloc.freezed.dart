// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'pairing_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$PairingEventTearOff {
  const _$PairingEventTearOff();

  _PairingStarted pairingStarted() {
    return const _PairingStarted();
  }

  _PairingSkipped pairingSkipped() {
    return const _PairingSkipped();
  }

  _CadenceConnected cadenceConnected() {
    return const _CadenceConnected();
  }

  _HeartrateConnected heartrateConnected() {
    return const _HeartrateConnected();
  }

  _FitnessmachineConnected fitnessmachineConnected() {
    return const _FitnessmachineConnected();
  }

  _CadenceDisconnected cadenceDisconnected() {
    return const _CadenceDisconnected();
  }

  _HeartrateDisconnected heartrateDisconnected() {
    return const _HeartrateDisconnected();
  }

  _FitnessmachineDisconnected fitnessmachineDisconnected() {
    return const _FitnessmachineDisconnected();
  }
}

/// @nodoc
const $PairingEvent = _$PairingEventTearOff();

/// @nodoc
mixin _$PairingEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pairingStarted,
    required TResult Function() pairingSkipped,
    required TResult Function() cadenceConnected,
    required TResult Function() heartrateConnected,
    required TResult Function() fitnessmachineConnected,
    required TResult Function() cadenceDisconnected,
    required TResult Function() heartrateDisconnected,
    required TResult Function() fitnessmachineDisconnected,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pairingStarted,
    TResult Function()? pairingSkipped,
    TResult Function()? cadenceConnected,
    TResult Function()? heartrateConnected,
    TResult Function()? fitnessmachineConnected,
    TResult Function()? cadenceDisconnected,
    TResult Function()? heartrateDisconnected,
    TResult Function()? fitnessmachineDisconnected,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PairingStarted value) pairingStarted,
    required TResult Function(_PairingSkipped value) pairingSkipped,
    required TResult Function(_CadenceConnected value) cadenceConnected,
    required TResult Function(_HeartrateConnected value) heartrateConnected,
    required TResult Function(_FitnessmachineConnected value)
        fitnessmachineConnected,
    required TResult Function(_CadenceDisconnected value) cadenceDisconnected,
    required TResult Function(_HeartrateDisconnected value)
        heartrateDisconnected,
    required TResult Function(_FitnessmachineDisconnected value)
        fitnessmachineDisconnected,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PairingStarted value)? pairingStarted,
    TResult Function(_PairingSkipped value)? pairingSkipped,
    TResult Function(_CadenceConnected value)? cadenceConnected,
    TResult Function(_HeartrateConnected value)? heartrateConnected,
    TResult Function(_FitnessmachineConnected value)? fitnessmachineConnected,
    TResult Function(_CadenceDisconnected value)? cadenceDisconnected,
    TResult Function(_HeartrateDisconnected value)? heartrateDisconnected,
    TResult Function(_FitnessmachineDisconnected value)?
        fitnessmachineDisconnected,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PairingEventCopyWith<$Res> {
  factory $PairingEventCopyWith(
          PairingEvent value, $Res Function(PairingEvent) then) =
      _$PairingEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$PairingEventCopyWithImpl<$Res> implements $PairingEventCopyWith<$Res> {
  _$PairingEventCopyWithImpl(this._value, this._then);

  final PairingEvent _value;
  // ignore: unused_field
  final $Res Function(PairingEvent) _then;
}

/// @nodoc
abstract class _$PairingStartedCopyWith<$Res> {
  factory _$PairingStartedCopyWith(
          _PairingStarted value, $Res Function(_PairingStarted) then) =
      __$PairingStartedCopyWithImpl<$Res>;
}

/// @nodoc
class __$PairingStartedCopyWithImpl<$Res>
    extends _$PairingEventCopyWithImpl<$Res>
    implements _$PairingStartedCopyWith<$Res> {
  __$PairingStartedCopyWithImpl(
      _PairingStarted _value, $Res Function(_PairingStarted) _then)
      : super(_value, (v) => _then(v as _PairingStarted));

  @override
  _PairingStarted get _value => super._value as _PairingStarted;
}

/// @nodoc

class _$_PairingStarted implements _PairingStarted {
  const _$_PairingStarted();

  @override
  String toString() {
    return 'PairingEvent.pairingStarted()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _PairingStarted);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pairingStarted,
    required TResult Function() pairingSkipped,
    required TResult Function() cadenceConnected,
    required TResult Function() heartrateConnected,
    required TResult Function() fitnessmachineConnected,
    required TResult Function() cadenceDisconnected,
    required TResult Function() heartrateDisconnected,
    required TResult Function() fitnessmachineDisconnected,
  }) {
    return pairingStarted();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pairingStarted,
    TResult Function()? pairingSkipped,
    TResult Function()? cadenceConnected,
    TResult Function()? heartrateConnected,
    TResult Function()? fitnessmachineConnected,
    TResult Function()? cadenceDisconnected,
    TResult Function()? heartrateDisconnected,
    TResult Function()? fitnessmachineDisconnected,
    required TResult orElse(),
  }) {
    if (pairingStarted != null) {
      return pairingStarted();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PairingStarted value) pairingStarted,
    required TResult Function(_PairingSkipped value) pairingSkipped,
    required TResult Function(_CadenceConnected value) cadenceConnected,
    required TResult Function(_HeartrateConnected value) heartrateConnected,
    required TResult Function(_FitnessmachineConnected value)
        fitnessmachineConnected,
    required TResult Function(_CadenceDisconnected value) cadenceDisconnected,
    required TResult Function(_HeartrateDisconnected value)
        heartrateDisconnected,
    required TResult Function(_FitnessmachineDisconnected value)
        fitnessmachineDisconnected,
  }) {
    return pairingStarted(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PairingStarted value)? pairingStarted,
    TResult Function(_PairingSkipped value)? pairingSkipped,
    TResult Function(_CadenceConnected value)? cadenceConnected,
    TResult Function(_HeartrateConnected value)? heartrateConnected,
    TResult Function(_FitnessmachineConnected value)? fitnessmachineConnected,
    TResult Function(_CadenceDisconnected value)? cadenceDisconnected,
    TResult Function(_HeartrateDisconnected value)? heartrateDisconnected,
    TResult Function(_FitnessmachineDisconnected value)?
        fitnessmachineDisconnected,
    required TResult orElse(),
  }) {
    if (pairingStarted != null) {
      return pairingStarted(this);
    }
    return orElse();
  }
}

abstract class _PairingStarted implements PairingEvent {
  const factory _PairingStarted() = _$_PairingStarted;
}

/// @nodoc
abstract class _$PairingSkippedCopyWith<$Res> {
  factory _$PairingSkippedCopyWith(
          _PairingSkipped value, $Res Function(_PairingSkipped) then) =
      __$PairingSkippedCopyWithImpl<$Res>;
}

/// @nodoc
class __$PairingSkippedCopyWithImpl<$Res>
    extends _$PairingEventCopyWithImpl<$Res>
    implements _$PairingSkippedCopyWith<$Res> {
  __$PairingSkippedCopyWithImpl(
      _PairingSkipped _value, $Res Function(_PairingSkipped) _then)
      : super(_value, (v) => _then(v as _PairingSkipped));

  @override
  _PairingSkipped get _value => super._value as _PairingSkipped;
}

/// @nodoc

class _$_PairingSkipped implements _PairingSkipped {
  const _$_PairingSkipped();

  @override
  String toString() {
    return 'PairingEvent.pairingSkipped()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _PairingSkipped);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pairingStarted,
    required TResult Function() pairingSkipped,
    required TResult Function() cadenceConnected,
    required TResult Function() heartrateConnected,
    required TResult Function() fitnessmachineConnected,
    required TResult Function() cadenceDisconnected,
    required TResult Function() heartrateDisconnected,
    required TResult Function() fitnessmachineDisconnected,
  }) {
    return pairingSkipped();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pairingStarted,
    TResult Function()? pairingSkipped,
    TResult Function()? cadenceConnected,
    TResult Function()? heartrateConnected,
    TResult Function()? fitnessmachineConnected,
    TResult Function()? cadenceDisconnected,
    TResult Function()? heartrateDisconnected,
    TResult Function()? fitnessmachineDisconnected,
    required TResult orElse(),
  }) {
    if (pairingSkipped != null) {
      return pairingSkipped();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PairingStarted value) pairingStarted,
    required TResult Function(_PairingSkipped value) pairingSkipped,
    required TResult Function(_CadenceConnected value) cadenceConnected,
    required TResult Function(_HeartrateConnected value) heartrateConnected,
    required TResult Function(_FitnessmachineConnected value)
        fitnessmachineConnected,
    required TResult Function(_CadenceDisconnected value) cadenceDisconnected,
    required TResult Function(_HeartrateDisconnected value)
        heartrateDisconnected,
    required TResult Function(_FitnessmachineDisconnected value)
        fitnessmachineDisconnected,
  }) {
    return pairingSkipped(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PairingStarted value)? pairingStarted,
    TResult Function(_PairingSkipped value)? pairingSkipped,
    TResult Function(_CadenceConnected value)? cadenceConnected,
    TResult Function(_HeartrateConnected value)? heartrateConnected,
    TResult Function(_FitnessmachineConnected value)? fitnessmachineConnected,
    TResult Function(_CadenceDisconnected value)? cadenceDisconnected,
    TResult Function(_HeartrateDisconnected value)? heartrateDisconnected,
    TResult Function(_FitnessmachineDisconnected value)?
        fitnessmachineDisconnected,
    required TResult orElse(),
  }) {
    if (pairingSkipped != null) {
      return pairingSkipped(this);
    }
    return orElse();
  }
}

abstract class _PairingSkipped implements PairingEvent {
  const factory _PairingSkipped() = _$_PairingSkipped;
}

/// @nodoc
abstract class _$CadenceConnectedCopyWith<$Res> {
  factory _$CadenceConnectedCopyWith(
          _CadenceConnected value, $Res Function(_CadenceConnected) then) =
      __$CadenceConnectedCopyWithImpl<$Res>;
}

/// @nodoc
class __$CadenceConnectedCopyWithImpl<$Res>
    extends _$PairingEventCopyWithImpl<$Res>
    implements _$CadenceConnectedCopyWith<$Res> {
  __$CadenceConnectedCopyWithImpl(
      _CadenceConnected _value, $Res Function(_CadenceConnected) _then)
      : super(_value, (v) => _then(v as _CadenceConnected));

  @override
  _CadenceConnected get _value => super._value as _CadenceConnected;
}

/// @nodoc

class _$_CadenceConnected implements _CadenceConnected {
  const _$_CadenceConnected();

  @override
  String toString() {
    return 'PairingEvent.cadenceConnected()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _CadenceConnected);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pairingStarted,
    required TResult Function() pairingSkipped,
    required TResult Function() cadenceConnected,
    required TResult Function() heartrateConnected,
    required TResult Function() fitnessmachineConnected,
    required TResult Function() cadenceDisconnected,
    required TResult Function() heartrateDisconnected,
    required TResult Function() fitnessmachineDisconnected,
  }) {
    return cadenceConnected();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pairingStarted,
    TResult Function()? pairingSkipped,
    TResult Function()? cadenceConnected,
    TResult Function()? heartrateConnected,
    TResult Function()? fitnessmachineConnected,
    TResult Function()? cadenceDisconnected,
    TResult Function()? heartrateDisconnected,
    TResult Function()? fitnessmachineDisconnected,
    required TResult orElse(),
  }) {
    if (cadenceConnected != null) {
      return cadenceConnected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PairingStarted value) pairingStarted,
    required TResult Function(_PairingSkipped value) pairingSkipped,
    required TResult Function(_CadenceConnected value) cadenceConnected,
    required TResult Function(_HeartrateConnected value) heartrateConnected,
    required TResult Function(_FitnessmachineConnected value)
        fitnessmachineConnected,
    required TResult Function(_CadenceDisconnected value) cadenceDisconnected,
    required TResult Function(_HeartrateDisconnected value)
        heartrateDisconnected,
    required TResult Function(_FitnessmachineDisconnected value)
        fitnessmachineDisconnected,
  }) {
    return cadenceConnected(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PairingStarted value)? pairingStarted,
    TResult Function(_PairingSkipped value)? pairingSkipped,
    TResult Function(_CadenceConnected value)? cadenceConnected,
    TResult Function(_HeartrateConnected value)? heartrateConnected,
    TResult Function(_FitnessmachineConnected value)? fitnessmachineConnected,
    TResult Function(_CadenceDisconnected value)? cadenceDisconnected,
    TResult Function(_HeartrateDisconnected value)? heartrateDisconnected,
    TResult Function(_FitnessmachineDisconnected value)?
        fitnessmachineDisconnected,
    required TResult orElse(),
  }) {
    if (cadenceConnected != null) {
      return cadenceConnected(this);
    }
    return orElse();
  }
}

abstract class _CadenceConnected implements PairingEvent {
  const factory _CadenceConnected() = _$_CadenceConnected;
}

/// @nodoc
abstract class _$HeartrateConnectedCopyWith<$Res> {
  factory _$HeartrateConnectedCopyWith(
          _HeartrateConnected value, $Res Function(_HeartrateConnected) then) =
      __$HeartrateConnectedCopyWithImpl<$Res>;
}

/// @nodoc
class __$HeartrateConnectedCopyWithImpl<$Res>
    extends _$PairingEventCopyWithImpl<$Res>
    implements _$HeartrateConnectedCopyWith<$Res> {
  __$HeartrateConnectedCopyWithImpl(
      _HeartrateConnected _value, $Res Function(_HeartrateConnected) _then)
      : super(_value, (v) => _then(v as _HeartrateConnected));

  @override
  _HeartrateConnected get _value => super._value as _HeartrateConnected;
}

/// @nodoc

class _$_HeartrateConnected implements _HeartrateConnected {
  const _$_HeartrateConnected();

  @override
  String toString() {
    return 'PairingEvent.heartrateConnected()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _HeartrateConnected);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pairingStarted,
    required TResult Function() pairingSkipped,
    required TResult Function() cadenceConnected,
    required TResult Function() heartrateConnected,
    required TResult Function() fitnessmachineConnected,
    required TResult Function() cadenceDisconnected,
    required TResult Function() heartrateDisconnected,
    required TResult Function() fitnessmachineDisconnected,
  }) {
    return heartrateConnected();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pairingStarted,
    TResult Function()? pairingSkipped,
    TResult Function()? cadenceConnected,
    TResult Function()? heartrateConnected,
    TResult Function()? fitnessmachineConnected,
    TResult Function()? cadenceDisconnected,
    TResult Function()? heartrateDisconnected,
    TResult Function()? fitnessmachineDisconnected,
    required TResult orElse(),
  }) {
    if (heartrateConnected != null) {
      return heartrateConnected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PairingStarted value) pairingStarted,
    required TResult Function(_PairingSkipped value) pairingSkipped,
    required TResult Function(_CadenceConnected value) cadenceConnected,
    required TResult Function(_HeartrateConnected value) heartrateConnected,
    required TResult Function(_FitnessmachineConnected value)
        fitnessmachineConnected,
    required TResult Function(_CadenceDisconnected value) cadenceDisconnected,
    required TResult Function(_HeartrateDisconnected value)
        heartrateDisconnected,
    required TResult Function(_FitnessmachineDisconnected value)
        fitnessmachineDisconnected,
  }) {
    return heartrateConnected(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PairingStarted value)? pairingStarted,
    TResult Function(_PairingSkipped value)? pairingSkipped,
    TResult Function(_CadenceConnected value)? cadenceConnected,
    TResult Function(_HeartrateConnected value)? heartrateConnected,
    TResult Function(_FitnessmachineConnected value)? fitnessmachineConnected,
    TResult Function(_CadenceDisconnected value)? cadenceDisconnected,
    TResult Function(_HeartrateDisconnected value)? heartrateDisconnected,
    TResult Function(_FitnessmachineDisconnected value)?
        fitnessmachineDisconnected,
    required TResult orElse(),
  }) {
    if (heartrateConnected != null) {
      return heartrateConnected(this);
    }
    return orElse();
  }
}

abstract class _HeartrateConnected implements PairingEvent {
  const factory _HeartrateConnected() = _$_HeartrateConnected;
}

/// @nodoc
abstract class _$FitnessmachineConnectedCopyWith<$Res> {
  factory _$FitnessmachineConnectedCopyWith(_FitnessmachineConnected value,
          $Res Function(_FitnessmachineConnected) then) =
      __$FitnessmachineConnectedCopyWithImpl<$Res>;
}

/// @nodoc
class __$FitnessmachineConnectedCopyWithImpl<$Res>
    extends _$PairingEventCopyWithImpl<$Res>
    implements _$FitnessmachineConnectedCopyWith<$Res> {
  __$FitnessmachineConnectedCopyWithImpl(_FitnessmachineConnected _value,
      $Res Function(_FitnessmachineConnected) _then)
      : super(_value, (v) => _then(v as _FitnessmachineConnected));

  @override
  _FitnessmachineConnected get _value =>
      super._value as _FitnessmachineConnected;
}

/// @nodoc

class _$_FitnessmachineConnected implements _FitnessmachineConnected {
  const _$_FitnessmachineConnected();

  @override
  String toString() {
    return 'PairingEvent.fitnessmachineConnected()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _FitnessmachineConnected);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pairingStarted,
    required TResult Function() pairingSkipped,
    required TResult Function() cadenceConnected,
    required TResult Function() heartrateConnected,
    required TResult Function() fitnessmachineConnected,
    required TResult Function() cadenceDisconnected,
    required TResult Function() heartrateDisconnected,
    required TResult Function() fitnessmachineDisconnected,
  }) {
    return fitnessmachineConnected();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pairingStarted,
    TResult Function()? pairingSkipped,
    TResult Function()? cadenceConnected,
    TResult Function()? heartrateConnected,
    TResult Function()? fitnessmachineConnected,
    TResult Function()? cadenceDisconnected,
    TResult Function()? heartrateDisconnected,
    TResult Function()? fitnessmachineDisconnected,
    required TResult orElse(),
  }) {
    if (fitnessmachineConnected != null) {
      return fitnessmachineConnected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PairingStarted value) pairingStarted,
    required TResult Function(_PairingSkipped value) pairingSkipped,
    required TResult Function(_CadenceConnected value) cadenceConnected,
    required TResult Function(_HeartrateConnected value) heartrateConnected,
    required TResult Function(_FitnessmachineConnected value)
        fitnessmachineConnected,
    required TResult Function(_CadenceDisconnected value) cadenceDisconnected,
    required TResult Function(_HeartrateDisconnected value)
        heartrateDisconnected,
    required TResult Function(_FitnessmachineDisconnected value)
        fitnessmachineDisconnected,
  }) {
    return fitnessmachineConnected(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PairingStarted value)? pairingStarted,
    TResult Function(_PairingSkipped value)? pairingSkipped,
    TResult Function(_CadenceConnected value)? cadenceConnected,
    TResult Function(_HeartrateConnected value)? heartrateConnected,
    TResult Function(_FitnessmachineConnected value)? fitnessmachineConnected,
    TResult Function(_CadenceDisconnected value)? cadenceDisconnected,
    TResult Function(_HeartrateDisconnected value)? heartrateDisconnected,
    TResult Function(_FitnessmachineDisconnected value)?
        fitnessmachineDisconnected,
    required TResult orElse(),
  }) {
    if (fitnessmachineConnected != null) {
      return fitnessmachineConnected(this);
    }
    return orElse();
  }
}

abstract class _FitnessmachineConnected implements PairingEvent {
  const factory _FitnessmachineConnected() = _$_FitnessmachineConnected;
}

/// @nodoc
abstract class _$CadenceDisconnectedCopyWith<$Res> {
  factory _$CadenceDisconnectedCopyWith(_CadenceDisconnected value,
          $Res Function(_CadenceDisconnected) then) =
      __$CadenceDisconnectedCopyWithImpl<$Res>;
}

/// @nodoc
class __$CadenceDisconnectedCopyWithImpl<$Res>
    extends _$PairingEventCopyWithImpl<$Res>
    implements _$CadenceDisconnectedCopyWith<$Res> {
  __$CadenceDisconnectedCopyWithImpl(
      _CadenceDisconnected _value, $Res Function(_CadenceDisconnected) _then)
      : super(_value, (v) => _then(v as _CadenceDisconnected));

  @override
  _CadenceDisconnected get _value => super._value as _CadenceDisconnected;
}

/// @nodoc

class _$_CadenceDisconnected implements _CadenceDisconnected {
  const _$_CadenceDisconnected();

  @override
  String toString() {
    return 'PairingEvent.cadenceDisconnected()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _CadenceDisconnected);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pairingStarted,
    required TResult Function() pairingSkipped,
    required TResult Function() cadenceConnected,
    required TResult Function() heartrateConnected,
    required TResult Function() fitnessmachineConnected,
    required TResult Function() cadenceDisconnected,
    required TResult Function() heartrateDisconnected,
    required TResult Function() fitnessmachineDisconnected,
  }) {
    return cadenceDisconnected();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pairingStarted,
    TResult Function()? pairingSkipped,
    TResult Function()? cadenceConnected,
    TResult Function()? heartrateConnected,
    TResult Function()? fitnessmachineConnected,
    TResult Function()? cadenceDisconnected,
    TResult Function()? heartrateDisconnected,
    TResult Function()? fitnessmachineDisconnected,
    required TResult orElse(),
  }) {
    if (cadenceDisconnected != null) {
      return cadenceDisconnected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PairingStarted value) pairingStarted,
    required TResult Function(_PairingSkipped value) pairingSkipped,
    required TResult Function(_CadenceConnected value) cadenceConnected,
    required TResult Function(_HeartrateConnected value) heartrateConnected,
    required TResult Function(_FitnessmachineConnected value)
        fitnessmachineConnected,
    required TResult Function(_CadenceDisconnected value) cadenceDisconnected,
    required TResult Function(_HeartrateDisconnected value)
        heartrateDisconnected,
    required TResult Function(_FitnessmachineDisconnected value)
        fitnessmachineDisconnected,
  }) {
    return cadenceDisconnected(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PairingStarted value)? pairingStarted,
    TResult Function(_PairingSkipped value)? pairingSkipped,
    TResult Function(_CadenceConnected value)? cadenceConnected,
    TResult Function(_HeartrateConnected value)? heartrateConnected,
    TResult Function(_FitnessmachineConnected value)? fitnessmachineConnected,
    TResult Function(_CadenceDisconnected value)? cadenceDisconnected,
    TResult Function(_HeartrateDisconnected value)? heartrateDisconnected,
    TResult Function(_FitnessmachineDisconnected value)?
        fitnessmachineDisconnected,
    required TResult orElse(),
  }) {
    if (cadenceDisconnected != null) {
      return cadenceDisconnected(this);
    }
    return orElse();
  }
}

abstract class _CadenceDisconnected implements PairingEvent {
  const factory _CadenceDisconnected() = _$_CadenceDisconnected;
}

/// @nodoc
abstract class _$HeartrateDisconnectedCopyWith<$Res> {
  factory _$HeartrateDisconnectedCopyWith(_HeartrateDisconnected value,
          $Res Function(_HeartrateDisconnected) then) =
      __$HeartrateDisconnectedCopyWithImpl<$Res>;
}

/// @nodoc
class __$HeartrateDisconnectedCopyWithImpl<$Res>
    extends _$PairingEventCopyWithImpl<$Res>
    implements _$HeartrateDisconnectedCopyWith<$Res> {
  __$HeartrateDisconnectedCopyWithImpl(_HeartrateDisconnected _value,
      $Res Function(_HeartrateDisconnected) _then)
      : super(_value, (v) => _then(v as _HeartrateDisconnected));

  @override
  _HeartrateDisconnected get _value => super._value as _HeartrateDisconnected;
}

/// @nodoc

class _$_HeartrateDisconnected implements _HeartrateDisconnected {
  const _$_HeartrateDisconnected();

  @override
  String toString() {
    return 'PairingEvent.heartrateDisconnected()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _HeartrateDisconnected);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pairingStarted,
    required TResult Function() pairingSkipped,
    required TResult Function() cadenceConnected,
    required TResult Function() heartrateConnected,
    required TResult Function() fitnessmachineConnected,
    required TResult Function() cadenceDisconnected,
    required TResult Function() heartrateDisconnected,
    required TResult Function() fitnessmachineDisconnected,
  }) {
    return heartrateDisconnected();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pairingStarted,
    TResult Function()? pairingSkipped,
    TResult Function()? cadenceConnected,
    TResult Function()? heartrateConnected,
    TResult Function()? fitnessmachineConnected,
    TResult Function()? cadenceDisconnected,
    TResult Function()? heartrateDisconnected,
    TResult Function()? fitnessmachineDisconnected,
    required TResult orElse(),
  }) {
    if (heartrateDisconnected != null) {
      return heartrateDisconnected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PairingStarted value) pairingStarted,
    required TResult Function(_PairingSkipped value) pairingSkipped,
    required TResult Function(_CadenceConnected value) cadenceConnected,
    required TResult Function(_HeartrateConnected value) heartrateConnected,
    required TResult Function(_FitnessmachineConnected value)
        fitnessmachineConnected,
    required TResult Function(_CadenceDisconnected value) cadenceDisconnected,
    required TResult Function(_HeartrateDisconnected value)
        heartrateDisconnected,
    required TResult Function(_FitnessmachineDisconnected value)
        fitnessmachineDisconnected,
  }) {
    return heartrateDisconnected(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PairingStarted value)? pairingStarted,
    TResult Function(_PairingSkipped value)? pairingSkipped,
    TResult Function(_CadenceConnected value)? cadenceConnected,
    TResult Function(_HeartrateConnected value)? heartrateConnected,
    TResult Function(_FitnessmachineConnected value)? fitnessmachineConnected,
    TResult Function(_CadenceDisconnected value)? cadenceDisconnected,
    TResult Function(_HeartrateDisconnected value)? heartrateDisconnected,
    TResult Function(_FitnessmachineDisconnected value)?
        fitnessmachineDisconnected,
    required TResult orElse(),
  }) {
    if (heartrateDisconnected != null) {
      return heartrateDisconnected(this);
    }
    return orElse();
  }
}

abstract class _HeartrateDisconnected implements PairingEvent {
  const factory _HeartrateDisconnected() = _$_HeartrateDisconnected;
}

/// @nodoc
abstract class _$FitnessmachineDisconnectedCopyWith<$Res> {
  factory _$FitnessmachineDisconnectedCopyWith(
          _FitnessmachineDisconnected value,
          $Res Function(_FitnessmachineDisconnected) then) =
      __$FitnessmachineDisconnectedCopyWithImpl<$Res>;
}

/// @nodoc
class __$FitnessmachineDisconnectedCopyWithImpl<$Res>
    extends _$PairingEventCopyWithImpl<$Res>
    implements _$FitnessmachineDisconnectedCopyWith<$Res> {
  __$FitnessmachineDisconnectedCopyWithImpl(_FitnessmachineDisconnected _value,
      $Res Function(_FitnessmachineDisconnected) _then)
      : super(_value, (v) => _then(v as _FitnessmachineDisconnected));

  @override
  _FitnessmachineDisconnected get _value =>
      super._value as _FitnessmachineDisconnected;
}

/// @nodoc

class _$_FitnessmachineDisconnected implements _FitnessmachineDisconnected {
  const _$_FitnessmachineDisconnected();

  @override
  String toString() {
    return 'PairingEvent.fitnessmachineDisconnected()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _FitnessmachineDisconnected);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pairingStarted,
    required TResult Function() pairingSkipped,
    required TResult Function() cadenceConnected,
    required TResult Function() heartrateConnected,
    required TResult Function() fitnessmachineConnected,
    required TResult Function() cadenceDisconnected,
    required TResult Function() heartrateDisconnected,
    required TResult Function() fitnessmachineDisconnected,
  }) {
    return fitnessmachineDisconnected();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pairingStarted,
    TResult Function()? pairingSkipped,
    TResult Function()? cadenceConnected,
    TResult Function()? heartrateConnected,
    TResult Function()? fitnessmachineConnected,
    TResult Function()? cadenceDisconnected,
    TResult Function()? heartrateDisconnected,
    TResult Function()? fitnessmachineDisconnected,
    required TResult orElse(),
  }) {
    if (fitnessmachineDisconnected != null) {
      return fitnessmachineDisconnected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PairingStarted value) pairingStarted,
    required TResult Function(_PairingSkipped value) pairingSkipped,
    required TResult Function(_CadenceConnected value) cadenceConnected,
    required TResult Function(_HeartrateConnected value) heartrateConnected,
    required TResult Function(_FitnessmachineConnected value)
        fitnessmachineConnected,
    required TResult Function(_CadenceDisconnected value) cadenceDisconnected,
    required TResult Function(_HeartrateDisconnected value)
        heartrateDisconnected,
    required TResult Function(_FitnessmachineDisconnected value)
        fitnessmachineDisconnected,
  }) {
    return fitnessmachineDisconnected(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PairingStarted value)? pairingStarted,
    TResult Function(_PairingSkipped value)? pairingSkipped,
    TResult Function(_CadenceConnected value)? cadenceConnected,
    TResult Function(_HeartrateConnected value)? heartrateConnected,
    TResult Function(_FitnessmachineConnected value)? fitnessmachineConnected,
    TResult Function(_CadenceDisconnected value)? cadenceDisconnected,
    TResult Function(_HeartrateDisconnected value)? heartrateDisconnected,
    TResult Function(_FitnessmachineDisconnected value)?
        fitnessmachineDisconnected,
    required TResult orElse(),
  }) {
    if (fitnessmachineDisconnected != null) {
      return fitnessmachineDisconnected(this);
    }
    return orElse();
  }
}

abstract class _FitnessmachineDisconnected implements PairingEvent {
  const factory _FitnessmachineDisconnected() = _$_FitnessmachineDisconnected;
}

/// @nodoc
class _$PairingStateTearOff {
  const _$PairingStateTearOff();

  _Initial initial() {
    return const _Initial();
  }

  _Pairing pairing(
      {required bool cadenceConnected,
      required bool heartrateConnected,
      required bool fitnessmachineConnected}) {
    return _Pairing(
      cadenceConnected: cadenceConnected,
      heartrateConnected: heartrateConnected,
      fitnessmachineConnected: fitnessmachineConnected,
    );
  }

  _Paired paired() {
    return const _Paired();
  }
}

/// @nodoc
const $PairingState = _$PairingStateTearOff();

/// @nodoc
mixin _$PairingState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(bool cadenceConnected, bool heartrateConnected,
            bool fitnessmachineConnected)
        pairing,
    required TResult Function() paired,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(bool cadenceConnected, bool heartrateConnected,
            bool fitnessmachineConnected)?
        pairing,
    TResult Function()? paired,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Pairing value) pairing,
    required TResult Function(_Paired value) paired,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Pairing value)? pairing,
    TResult Function(_Paired value)? paired,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PairingStateCopyWith<$Res> {
  factory $PairingStateCopyWith(
          PairingState value, $Res Function(PairingState) then) =
      _$PairingStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$PairingStateCopyWithImpl<$Res> implements $PairingStateCopyWith<$Res> {
  _$PairingStateCopyWithImpl(this._value, this._then);

  final PairingState _value;
  // ignore: unused_field
  final $Res Function(PairingState) _then;
}

/// @nodoc
abstract class _$InitialCopyWith<$Res> {
  factory _$InitialCopyWith(_Initial value, $Res Function(_Initial) then) =
      __$InitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$InitialCopyWithImpl<$Res> extends _$PairingStateCopyWithImpl<$Res>
    implements _$InitialCopyWith<$Res> {
  __$InitialCopyWithImpl(_Initial _value, $Res Function(_Initial) _then)
      : super(_value, (v) => _then(v as _Initial));

  @override
  _Initial get _value => super._value as _Initial;
}

/// @nodoc

class _$_Initial implements _Initial {
  const _$_Initial();

  @override
  String toString() {
    return 'PairingState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(bool cadenceConnected, bool heartrateConnected,
            bool fitnessmachineConnected)
        pairing,
    required TResult Function() paired,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(bool cadenceConnected, bool heartrateConnected,
            bool fitnessmachineConnected)?
        pairing,
    TResult Function()? paired,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Pairing value) pairing,
    required TResult Function(_Paired value) paired,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Pairing value)? pairing,
    TResult Function(_Paired value)? paired,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements PairingState {
  const factory _Initial() = _$_Initial;
}

/// @nodoc
abstract class _$PairingCopyWith<$Res> {
  factory _$PairingCopyWith(_Pairing value, $Res Function(_Pairing) then) =
      __$PairingCopyWithImpl<$Res>;
  $Res call(
      {bool cadenceConnected,
      bool heartrateConnected,
      bool fitnessmachineConnected});
}

/// @nodoc
class __$PairingCopyWithImpl<$Res> extends _$PairingStateCopyWithImpl<$Res>
    implements _$PairingCopyWith<$Res> {
  __$PairingCopyWithImpl(_Pairing _value, $Res Function(_Pairing) _then)
      : super(_value, (v) => _then(v as _Pairing));

  @override
  _Pairing get _value => super._value as _Pairing;

  @override
  $Res call({
    Object? cadenceConnected = freezed,
    Object? heartrateConnected = freezed,
    Object? fitnessmachineConnected = freezed,
  }) {
    return _then(_Pairing(
      cadenceConnected: cadenceConnected == freezed
          ? _value.cadenceConnected
          : cadenceConnected // ignore: cast_nullable_to_non_nullable
              as bool,
      heartrateConnected: heartrateConnected == freezed
          ? _value.heartrateConnected
          : heartrateConnected // ignore: cast_nullable_to_non_nullable
              as bool,
      fitnessmachineConnected: fitnessmachineConnected == freezed
          ? _value.fitnessmachineConnected
          : fitnessmachineConnected // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_Pairing implements _Pairing {
  const _$_Pairing(
      {required this.cadenceConnected,
      required this.heartrateConnected,
      required this.fitnessmachineConnected});

  @override
  final bool cadenceConnected;
  @override
  final bool heartrateConnected;
  @override
  final bool fitnessmachineConnected;

  @override
  String toString() {
    return 'PairingState.pairing(cadenceConnected: $cadenceConnected, heartrateConnected: $heartrateConnected, fitnessmachineConnected: $fitnessmachineConnected)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Pairing &&
            (identical(other.cadenceConnected, cadenceConnected) ||
                const DeepCollectionEquality()
                    .equals(other.cadenceConnected, cadenceConnected)) &&
            (identical(other.heartrateConnected, heartrateConnected) ||
                const DeepCollectionEquality()
                    .equals(other.heartrateConnected, heartrateConnected)) &&
            (identical(
                    other.fitnessmachineConnected, fitnessmachineConnected) ||
                const DeepCollectionEquality().equals(
                    other.fitnessmachineConnected, fitnessmachineConnected)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(cadenceConnected) ^
      const DeepCollectionEquality().hash(heartrateConnected) ^
      const DeepCollectionEquality().hash(fitnessmachineConnected);

  @JsonKey(ignore: true)
  @override
  _$PairingCopyWith<_Pairing> get copyWith =>
      __$PairingCopyWithImpl<_Pairing>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(bool cadenceConnected, bool heartrateConnected,
            bool fitnessmachineConnected)
        pairing,
    required TResult Function() paired,
  }) {
    return pairing(
        cadenceConnected, heartrateConnected, fitnessmachineConnected);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(bool cadenceConnected, bool heartrateConnected,
            bool fitnessmachineConnected)?
        pairing,
    TResult Function()? paired,
    required TResult orElse(),
  }) {
    if (pairing != null) {
      return pairing(
          cadenceConnected, heartrateConnected, fitnessmachineConnected);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Pairing value) pairing,
    required TResult Function(_Paired value) paired,
  }) {
    return pairing(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Pairing value)? pairing,
    TResult Function(_Paired value)? paired,
    required TResult orElse(),
  }) {
    if (pairing != null) {
      return pairing(this);
    }
    return orElse();
  }
}

abstract class _Pairing implements PairingState {
  const factory _Pairing(
      {required bool cadenceConnected,
      required bool heartrateConnected,
      required bool fitnessmachineConnected}) = _$_Pairing;

  bool get cadenceConnected => throw _privateConstructorUsedError;
  bool get heartrateConnected => throw _privateConstructorUsedError;
  bool get fitnessmachineConnected => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$PairingCopyWith<_Pairing> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$PairedCopyWith<$Res> {
  factory _$PairedCopyWith(_Paired value, $Res Function(_Paired) then) =
      __$PairedCopyWithImpl<$Res>;
}

/// @nodoc
class __$PairedCopyWithImpl<$Res> extends _$PairingStateCopyWithImpl<$Res>
    implements _$PairedCopyWith<$Res> {
  __$PairedCopyWithImpl(_Paired _value, $Res Function(_Paired) _then)
      : super(_value, (v) => _then(v as _Paired));

  @override
  _Paired get _value => super._value as _Paired;
}

/// @nodoc

class _$_Paired implements _Paired {
  const _$_Paired();

  @override
  String toString() {
    return 'PairingState.paired()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Paired);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(bool cadenceConnected, bool heartrateConnected,
            bool fitnessmachineConnected)
        pairing,
    required TResult Function() paired,
  }) {
    return paired();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(bool cadenceConnected, bool heartrateConnected,
            bool fitnessmachineConnected)?
        pairing,
    TResult Function()? paired,
    required TResult orElse(),
  }) {
    if (paired != null) {
      return paired();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Pairing value) pairing,
    required TResult Function(_Paired value) paired,
  }) {
    return paired(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Pairing value)? pairing,
    TResult Function(_Paired value)? paired,
    required TResult orElse(),
  }) {
    if (paired != null) {
      return paired(this);
    }
    return orElse();
  }
}

abstract class _Paired implements PairingState {
  const factory _Paired() = _$_Paired;
}
